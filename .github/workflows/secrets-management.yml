name: Secrets Management and Deployment

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod
      deploy_secrets:
        description: 'Deploy secrets to cluster'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: quay.io
  IMAGE_NAME: kohler/openshift-config

jobs:
  validate-secrets:
    name: Validate Secret Templates
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Validate YAML syntax
        run: |
          find components/ -name "*.yaml" -type f | while read file; do
            echo "Validating $file"
            kubectl --dry-run=client apply -f "$file" --validate=true || exit 1
          done

      - name: Check for plaintext secrets
        run: |
          echo "Checking for potential plaintext secrets..."
          
          # Check for common secret patterns that shouldn't be in plaintext
          SECRET_PATTERNS=(
            "password.*:"
            "token.*:"
            "key.*:"
            "secret.*:"
            "credential.*:"
            "aws_access_key_id.*[^X]"
            "aws_secret_access_key.*[^X]"
            "clientSecret.*[^R]"
          )
          
          FOUND_SECRETS=false
          
          for pattern in "${SECRET_PATTERNS[@]}"; do
            if grep -r -i "$pattern" components/ --include="*.yaml" | grep -v "REPLACE_WITH\|YOUR_\|PLACEHOLDER\|XXX"; then
              echo "❌ Found potential plaintext secret: $pattern"
              FOUND_SECRETS=true
            fi
          done
          
          if [ "$FOUND_SECRETS" = true ]; then
            echo "❌ Plaintext secrets detected! Please use GitHub Secrets or sealed secrets."
            exit 1
          else
            echo "✅ No plaintext secrets detected."
          fi

  generate-sealed-secrets:
    name: Generate Sealed Secrets
    runs-on: ubuntu-latest
    needs: validate-secrets
    if: github.event_name == 'push' || github.event.inputs.deploy_secrets == 'true'
    environment: ${{ github.event.inputs.environment || 'dev' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install kubeseal
        run: |
          wget https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.24.0/kubeseal-0.24.0-linux-amd64.tar.gz
          tar -xvzf kubeseal-0.24.0-linux-amd64.tar.gz kubeseal
          sudo install -m 755 kubeseal /usr/local/bin/kubeseal

      - name: Generate Azure AD Client Secret
        env:
          AZURE_AD_CLIENT_SECRET: ${{ secrets.AZURE_AD_CLIENT_SECRET }}
          KUBESEAL_CERT: ${{ secrets.KUBESEAL_CERT }}
        run: |
          if [ -n "$AZURE_AD_CLIENT_SECRET" ] && [ -n "$KUBESEAL_CERT" ]; then
            echo "$KUBESEAL_CERT" > kubeseal-cert.pem
            
            kubectl create secret generic openid-client-secret-azuread \
              --namespace=openshift-config \
              --from-literal=clientSecret="$AZURE_AD_CLIENT_SECRET" \
              --dry-run=client -o yaml | \
            kubeseal --cert kubeseal-cert.pem -o yaml > components/oauth-configuration/azure-ad-client-sealed-secret.yaml
            
            echo "✅ Generated sealed secret for Azure AD client"
          else
            echo "⚠️  Azure AD client secret or kubeseal certificate not available"
          fi

      - name: Generate OADP Backup Credentials
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.OADP_AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.OADP_AWS_SECRET_ACCESS_KEY }}
          KUBESEAL_CERT: ${{ secrets.KUBESEAL_CERT }}
        run: |
          if [ -n "$AWS_ACCESS_KEY_ID" ] && [ -n "$AWS_SECRET_ACCESS_KEY" ] && [ -n "$KUBESEAL_CERT" ]; then
            echo "$KUBESEAL_CERT" > kubeseal-cert.pem
            
            cat > cloud-credentials.txt << EOF
          [default]
          aws_access_key_id=$AWS_ACCESS_KEY_ID
          aws_secret_access_key=$AWS_SECRET_ACCESS_KEY
          EOF
            
            kubectl create secret generic cloud-credentials \
              --namespace=openshift-adp \
              --from-file=cloud=cloud-credentials.txt \
              --dry-run=client -o yaml | \
            kubeseal --cert kubeseal-cert.pem -o yaml > components/oadp-configuration/backup-storage-sealed-secret.yaml
            
            rm cloud-credentials.txt
            echo "✅ Generated sealed secret for OADP backup credentials"
          else
            echo "⚠️  OADP credentials or kubeseal certificate not available"
          fi

      - name: Generate Additional Secrets
        env:
          REGISTRY_USERNAME: ${{ secrets.REGISTRY_USERNAME }}
          REGISTRY_PASSWORD: ${{ secrets.REGISTRY_PASSWORD }}
          KUBESEAL_CERT: ${{ secrets.KUBESEAL_CERT }}
        run: |
          if [ -n "$REGISTRY_USERNAME" ] && [ -n "$REGISTRY_PASSWORD" ] && [ -n "$KUBESEAL_CERT" ]; then
            echo "$KUBESEAL_CERT" > kubeseal-cert.pem
            
            kubectl create secret docker-registry registry-credentials \
              --namespace=openshift-config \
              --docker-server=quay.io \
              --docker-username="$REGISTRY_USERNAME" \
              --docker-password="$REGISTRY_PASSWORD" \
              --dry-run=client -o yaml | \
            kubeseal --cert kubeseal-cert.pem -o yaml > components/registry-configuration/registry-sealed-secret.yaml
            
            echo "✅ Generated sealed secret for registry credentials"
          else
            echo "⚠️  Registry credentials or kubeseal certificate not available"
          fi

      - name: Commit and push sealed secrets
        if: github.event_name == 'push'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          if [ -f components/oauth-configuration/azure-ad-client-sealed-secret.yaml ]; then
            git add components/oauth-configuration/azure-ad-client-sealed-secret.yaml
          fi
          
          if [ -f components/oadp-configuration/backup-storage-sealed-secret.yaml ]; then
            git add components/oadp-configuration/backup-storage-sealed-secret.yaml
          fi
          
          if [ -f components/registry-configuration/registry-sealed-secret.yaml ]; then
            git add components/registry-configuration/registry-sealed-secret.yaml
          fi
          
          if git diff --staged --quiet; then
            echo "No sealed secrets to commit"
          else
            git commit -m "Update sealed secrets [skip ci]"
            git push
          fi

  deploy-to-cluster:
    name: Deploy to OpenShift Cluster
    runs-on: ubuntu-latest
    needs: [validate-secrets, generate-sealed-secrets]
    if: github.event.inputs.deploy_secrets == 'true' || (github.event_name == 'push' && github.ref == 'refs/heads/main')
    environment: ${{ github.event.inputs.environment || 'prod' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up OpenShift CLI
        uses: redhat-actions/openshift-tools-installer@v1
        with:
          oc: 4

      - name: Login to OpenShift
        env:
          OPENSHIFT_SERVER: ${{ secrets.OPENSHIFT_SERVER }}
          OPENSHIFT_TOKEN: ${{ secrets.OPENSHIFT_TOKEN }}
        run: |
          oc login --token="$OPENSHIFT_TOKEN" --server="$OPENSHIFT_SERVER" --insecure-skip-tls-verify=true

      - name: Deploy Sealed Secrets Controller (if not exists)
        run: |
          if ! oc get namespace sealed-secrets-system 2>/dev/null; then
            echo "Installing Sealed Secrets Controller..."
            oc apply -f https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.24.0/controller.yaml
            oc wait --for=condition=available --timeout=300s deployment/sealed-secrets-controller -n sealed-secrets-system
          else
            echo "Sealed Secrets Controller already installed"
          fi

      - name: Apply sealed secrets
        run: |
          echo "Applying sealed secrets..."
          
          # Apply sealed secrets if they exist
          for secret_file in components/*/sealed-secret.yaml components/*/*-sealed-secret.yaml; do
            if [ -f "$secret_file" ]; then
              echo "Applying $secret_file"
              oc apply -f "$secret_file"
            fi
          done

      - name: Verify secret deployment
        run: |
          echo "Verifying secrets are properly created..."
          
          # Check Azure AD secret
          if oc get secret openid-client-secret-azuread -n openshift-config 2>/dev/null; then
            echo "✅ Azure AD client secret exists"
          else
            echo "❌ Azure AD client secret missing"
          fi
          
          # Check OADP backup credentials
          if oc get secret cloud-credentials -n openshift-adp 2>/dev/null; then
            echo "✅ OADP backup credentials exist"
          else
            echo "❌ OADP backup credentials missing"
          fi

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'
